import * as React from "react";
import { connect } from "react-redux";

import { State } from "state";
import { addPokemon, addBox } from "actions";
import {
    feature,
    isLocal,
    choose,
    generateEmptyPokemon,
    matchSpeciesToTypes,
    Types,
    Forme,
    getBadges,
    movesByType,
} from "utils";
import { ErrorBoundary } from "components";
import { Button } from "@blueprintjs/core";
import { appSelector } from "selectors";
import { Skeleton } from "components";
import {
    listOfAbilities,
    listOfItems,
    listOfNatures,
    listOfPokeballs,
    listOfPokemon,
    listOfGames,
    locations,
    Species,
} from "utils/data";
import { Pokemon } from "models";
import { DebugDialog } from "./DebugDialog";

import "./app.css";

export interface AppProps {
    style: State["style"];
    view: State["view"];
    pokemon: State["pokemon"];
    addPokemon: typeof addPokemon;
    addBox: typeof addBox;
}

const Editor = React.lazy(() =>
    import("components/Editors/Editor").then((res) => ({
        default: res.Editor,
    })),
);

const Result = React.lazy(() =>
    import("components/Features/Result/Result").then((res) => ({
        default: res.Result,
    })),
);

const Result2 = React.lazy(() =>
    import("components/Features/Result/Result2").then((res) => ({
        default: res.Result,
    })),
);

const ImagesDrawer = React.lazy(() =>
    import("components/Common/Shared/ImagesDrawer").then((res) => ({
        default: res.ImagesDrawer,
    })),
);

const BugReporter = React.lazy(() =>
    import("components/Features/BugReporter").then((res) => ({
        default: res.BugReporter,
    })),
);

const Hotkeys = React.lazy(() =>
    import("components/Features/Hotkeys").then((res) => ({
        default: res.Hotkeys,
    })),
);

const statusOptions = [
    "Team",
    "Team",
    "Boxed",
    "Boxed",
    "Dead",
    "Graveyard",
    "Daycare",
    "Released",
];
const nicknamePrefixes = [
    "Debug",
    "Glitched",
    "Lucky",
    "Rusty",
    "Shiny-ish",
    "Proto",
    "Shadow",
];
const noteSnippets = [
    "Generated by debug dialog",
    "Caught while testing",
    "Placeholder entry",
    "Transferred from another save",
    "Auto-filled for QA",
];
const deathReasons = [
    "Critical hit",
    "Unlucky burn tick",
    "Destiny Bond",
    "Sandstorm chip",
    "Self-Destruct",
    "Arena trap misplay",
    "Rival battle",
    "Unknown",
];

const genderOptions: Array<Pokemon["gender"]> = [
    "m",
    "f",
    "Male",
    "Female",
    "genderless",
    null,
    undefined,
];

const typePool = Object.values(Types);
const formePool = Object.values(Forme);
const moveTypePool = Object.keys(movesByType) as Array<
    keyof typeof movesByType
>;
const locationPool = Object.values(locations).flat();

const randomInt = (min: number, max: number) =>
    Math.floor(Math.random() * (max - min + 1)) + min;

const randomBool = (chance: number = 0.5) => Math.random() < chance;

const maybe = <T,>(value: () => T, undefinedChance = 0.25): T | undefined =>
    randomBool(undefinedChance) ? undefined : value();

const maybeNull = <T,>(value: () => T, nullChance = 0.1): T | null =>
    randomBool(nullChance) ? null : value();

const buildRandomMoves = (types?: [Types, Types]) => {
    const typeCandidates = (types ?? []).filter(
        (type): type is keyof typeof movesByType =>
            Boolean(type && movesByType[type as keyof typeof movesByType]),
    );

    const moveType =
        typeCandidates.length > 0
            ? choose(typeCandidates)
            : choose(moveTypePool);

    const pool = movesByType[moveType] ?? [];
    const moves = new Set<string>();
    const moveCount = randomInt(1, 4);

    for (let i = 0; i < moveCount && pool.length > 0; i++) {
        moves.add(choose(pool));
    }

    return Array.from(moves);
};

const randomCheckpoints = (game: (typeof listOfGames)[number]) => {
    const badgePool = getBadges(game);
    if (!badgePool.length || !randomBool(0.35)) return undefined;

    return badgePool.slice(0, randomInt(1, badgePool.length));
};

const randomLinkedPokemon = (existingPokemon: Pokemon[]) => {
    if (!existingPokemon.length || !randomBool(0.35)) return null;
    return maybeNull(() => choose(existingPokemon).id, 0.35);
};

const randomTypes = (species: Species) =>
    maybe(
        () =>
            matchSpeciesToTypes(species) ?? [
                choose(typePool),
                choose(typePool),
            ],
        0.1,
    );

const buildRandomPokemonAttributes = (
    existingPokemon: Pokemon[],
): Partial<Pokemon> => {
    const species = choose([...listOfPokemon]) as Species;
    const types = randomTypes(species);
    const status = choose(statusOptions);
    const gameOfOrigin = choose(listOfGames);
    const checkpoints = randomCheckpoints(gameOfOrigin);
    const deadStatus = status === "Dead" || status === "Graveyard";

    return {
        species,
        status,
        level: maybe(() => randomInt(1, 100), 0.15),
        nickname: maybe(
            () => `${choose(nicknamePrefixes)} ${species}`,
            0.2,
        ),
        gender: choose(genderOptions),
        met: maybe(() => choose(locationPool)),
        metLevel: maybe(() => randomInt(1, 60)),
        nature: maybe(() => choose(listOfNatures)),
        ability: maybe(() => choose(listOfAbilities)),
        moves: buildRandomMoves(types),
        causeOfDeath: deadStatus
            ? maybe(() => choose(deathReasons), 0.25)
            : undefined,
        deathTimestamp:
            deadStatus && randomBool(0.4)
                ? new Date(
                      Date.now() - randomInt(0, 30) * 86_400_000,
                  ).toISOString()
                : undefined,
        forme: maybe(() => choose(formePool), 0.35),
        item: maybe(() => choose(listOfItems)),
        types,
        teraType: maybe(() => choose(typePool), 0.3),
        customImage: maybe(
            () => `https://picsum.photos/seed/${randomInt(1, 9999)}/200/200`,
            0.55,
        ),
        customIcon: maybe(
            () => `https://picsum.photos/seed/${randomInt(1, 9999)}/64/64`,
            0.6,
        ),
        customItemImage: maybe(
            () => `https://picsum.photos/seed/${randomInt(1, 9999)}/32/32`,
            0.65,
        ),
        shiny: randomBool(0.18),
        badges: checkpoints?.map((badge) => badge.name),
        num: maybe(() => String(randomInt(1, 1025))),
        wonderTradedFor: maybe(() => choose<Species>([...listOfPokemon])),
        mvp: randomBool(0.12),
        gameOfOrigin,
        egg: randomBool(0.08),
        hidden: randomBool(0.2),
        extraData: randomBool(0.4)
            ? {
                  debugSeed: randomInt(0, 99999),
                  note: choose(noteSnippets),
              }
            : undefined,
        pokeball: maybe(() => choose(listOfPokeballs)),
        notes: maybe(() => choose(noteSnippets)),
        linkedTo: randomLinkedPokemon(existingPokemon),
        checkpoints,
        gift: randomBool(0.18),
        champion: randomBool(0.12),
        alpha: randomBool(0.2),
    };
};

export class AppBase extends React.Component<AppProps, { result2?: boolean }> {
    public constructor(props: AppProps) {
        super(props);
        this.state = { result2: false };
    }

    private addRandomPokemon = () => {
        const pokemon = generateEmptyPokemon(
            this.props.pokemon,
            buildRandomPokemonAttributes(this.props.pokemon),
        );
        this.props.addPokemon(pokemon);
    };

    private createRandomBox = (count: number) => {
        const boxName = `Random Box ${Date.now()}`;
        this.props.addBox({
            name: boxName,
            background: "",
            inheritFrom: "Boxed",
        });

        for (let i = 0; i < count; i++) {
            const species = choose([...listOfPokemon]) as Species;
            const types = matchSpeciesToTypes(species);
            const pokemon = generateEmptyPokemon(this.props.pokemon, {
                species,
                status: boxName,
                types,
            });
            this.props.addPokemon(pokemon);
        }
    };

    private updateDarkModeClass = () => {
        const isDarkMode = this.props.style.editorDarkMode;
        if (isDarkMode) {
            document.documentElement.classList.add("dark");
        } else {
            document.documentElement.classList.remove("dark");
        }
    };

    public componentDidMount() {
        this.updateDarkModeClass();

        if (feature.resultv2) {
            // TOP SECRET
            if (this.props.style.customCSS.includes("resultv2")) {
                this.setState({ result2: true });
            } else {
                this.setState({ result2: false });
            }
        }
    }

    public componentDidUpdate(prevProps: AppProps) {
        if (prevProps.style.editorDarkMode !== this.props.style.editorDarkMode) {
            this.updateDarkModeClass();
        }
    }

    public render() {
        const { style, view } = this.props;
        const { result2 } = this.state;
        const isDarkMode = style.editorDarkMode;
        const showDebugPanel = isLocal();
        console.log("features", feature);

        return (
            <ErrorBoundary
                errorMessage={
                    <div className="p-6 center-text">
                        <h2>
                            There was a problem retrieving your nuzlocke data.
                        </h2>
                        <p>Please consider submitting a bug report.</p>

                        <React.Suspense fallback={"Loading Bug Reporter..."}>
                            <BugReporter defaultOpen />
                        </React.Suspense>
                    </div>
                }
            >
                <div
                    data-testid="app"
                    className="app"
                    role="main"
                    style={{
                        background: this.props.style.editorDarkMode
                            ? "#111"
                            : "#fff",
                    }}
                >
                    <ErrorBoundary key={1}>
                        <React.Suspense fallback={Skeleton}>
                            <Hotkeys />
                        </React.Suspense>
                    </ErrorBoundary>
                    <ErrorBoundary key={2}>
                        <React.Suspense fallback={Skeleton}>
                            <Editor />
                        </React.Suspense>
                    </ErrorBoundary>
                    {result2 ? (
                        <ErrorBoundary key={3}>
                            <React.Suspense fallback={Skeleton}>
                                <Result2 />
                            </React.Suspense>
                        </ErrorBoundary>
                    ) : (
                        <ErrorBoundary key={3}>
                            <React.Suspense fallback={Skeleton}>
                                <Result />
                            </React.Suspense>
                        </ErrorBoundary>
                    )}

                    {showDebugPanel && feature.resultv2 && (
                        <Button
                            style={{
                                position: "absolute",
                                top: "0.5rem",
                                right: "0.5rem",
                                zIndex: 1000,
                            }}
                            onClick={(e) =>
                                this.setState({ result2: !result2 })
                            }
                        >
                            Use Result v2
                        </Button>
                    )}

                    {showDebugPanel && (
                        <DebugDialog
                            onAddRandomPokemon={this.addRandomPokemon}
                            onCreateRandomBox={this.createRandomBox}
                        />
                    )}

                    <ErrorBoundary key={4}>
                        <React.Suspense fallback={Skeleton}>
                            <ImagesDrawer />
                        </React.Suspense>
                    </ErrorBoundary>
                </div>
            </ErrorBoundary>
        );
    }
}

export const App = connect(appSelector, { addPokemon, addBox })(AppBase);
